## ПЗ-8 Славінський Костянтин ЦК-31
За заданим завданням виконана на основі минулоні ПЗ-7

Код знаходиться у папці (src)

Структура (src):
1. Файл Product.java
Додано equals та hashCode.

2. Файл StoreItem.java
Додано equals та hashCode.

3. ФайлOnlineStore.java
List замінено на Set (HashSet).

4. Файл ProductSearchService.java
List магазинів замінено на Set. Додано нову функцію з Map.

## Контрольні питання 

**1. Чим інтерфейс Set відрізняється від інтерфейсів Collection та List?**
* **Від Collection:** `Set` не додає нових методів до інтерфейсу `Collection`, але накладає обмеження — забороняє дублікати елементів.
* **Від List:** `List` — це впорядкована колекція (має індекси), дозволяє дублікати. `Set` — це колекція унікальних елементів, яка (у більшості реалізацій, як `HashSet`) не гарантує порядок зберігання і не має доступу за індексом.

**2. Чим HashSet відрізняється від TreeSet?**
* **HashSet:** Використовує хеш-таблицю. Дуже швидкий ($O(1)$ для базових операцій), але не зберігає порядок елементів.
* **TreeSet:** Використовує червоно-чорне дерево. Повільніший ($O(\log n)$), але зберігає елементи у відсортованому вигляді. Вимагає, щоб елементи реалізовували інтерфейс `Comparable`.

**3. Що таке хешування, хеш, хеш-код, хеш-функція?**
* **Хешування:** Процес перетворення вхідних даних довільного розміру у рядок фіксованого розміру.
* **Хеш (хеш-код):** Числове значення (`int`), яке повертає хеш-функція для конкретного об'єкта.
* **Хеш-функція:** Алгоритм (у Java метод `hashCode()`), який обчислює хеш-код для об'єкта.

**4. Яким вимогам має відповідати коректна хеш-функція?**
1. Якщо `x.equals(y) == true`, то `x.hashCode()` має дорівнювати `y.hashCode()`.
2. Виклик методу кілька разів на одному об'єкті (якщо його поля не змінились) має повертати те саме значення.
3. *Бажано:* Для різних об'єктів повертати різні хеш-коди (мінімізація колізій).

**5. Які властивості притаманні хорошій хеш-функції?**
Рівномірний розподіл хеш-кодів по всьому діапазону значень `int`, щоб уникнути скупчення об'єктів в одній комірці (колізій), що забезпечує швидкий пошук.

**6. Якими критеріям мають відповідати об’єкти для того, щоб посилання на них можна було зберігати у HashSet?**
У класі цих об'єктів мають бути коректно перевизначені методи `equals()` та `hashCode()`.

**7. Які є переваги/недоліки використання HashSet у порівнянні з TreeSet?**
* **Переваги HashSet:** Значно вища швидкість роботи ($O(1)$ проти $O(\log n)$). Не вимагає реалізації `Comparable`.
* **Недоліки:** Не впорядковує елементи.

**8. Чим поняття size відрізняється від capacity? Чи може size бути більший за capacity?**
* **Size:** Кількість елементів, які фактично зараз зберігаються в колекції.
* **Capacity (Ємність):** Кількість комірок (buckets), виділених у пам'яті під хеш-таблицю.
* `size` **не може** бути більшим за `capacity`. Коли `size` наближається до `capacity` (досягає `load factor`), `capacity` автоматично збільшується. `Capacity` може бути (і зазвичай є) більшим за `size`.

**9. Що таке load factor та на що і як він впливає?**
Це коефіцієнт заповнення (за замовчуванням 0.75). Він визначає, наскільки заповненою може бути хеш-таблиця до того, як її ємність буде автоматично збільшено (rehashing). Менший `load factor` зменшує колізії, але витрачає більше пам'яті.

**10. Що таке асоціативний масив? Чим ключ відрізняється від значення?**
Це структура даних, що зберігає пари "ключ — значення".
* **Ключ (Key):** Унікальний ідентифікатор елемента. По ньому здійснюється пошук.
* **Значення (Value):** Дані, прив'язані до ключа. Можуть дублюватися.

**11. Чи може в асоціативному масиві зберігатись кілька однакових ключів або однакових значень?**
* **Ключів:** Ні, ключі мають бути унікальними (новий перезапише старий).
* **Значень:** Так, значення можуть дублюватися.

**12. До яких наслідків може привести зберігання неімутабельних (змінюваних) об’єктів у HashSet/HashMap як ключа?**
Якщо змінити поля об'єкта, який вже лежить у `Set` або є ключем у `Map`, його `hashCode` зміниться. В результаті колекція не зможе знайти цей об'єкт, навіть якщо він там є. Це призводить до втрати даних та непередбачуваної поведінки ("витік пам'яті").

**13. Чи можуть об’єкти без інтерфейсу Comparable зберігатись у TreeMap?**
Ні (або так, якщо в конструктор `TreeMap` передати окремий `Comparator`). Без компаратора виникне помилка `ClassCastException`.

**14. Чи можуть об’єкти без інтерфейсу Comparable зберігатись у HashMap?**
Так, для `HashMap` інтерфейс `Comparable` не потрібен, потрібні лише `equals()` та `hashCode()`.

